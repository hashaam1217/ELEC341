% Practice Final 1
% Author: Hashaam Zafar
% Date: 19/12/2025

%% Setup
clear; clc; 
SN = 10078020; 
A = 11; 
B = 10;
C = 10; 
D = 17; 
E = 18; 
F = 10; 
G = 12; 
H = 10; 

s = tf('s');
j = 1i;


% Table 1
Z1 = A; % Teeth
Z2 = B * 3; % Teeth
Mod = 2 * 1e-3; % mm
J1 = C * 3e-6; % Nms^2/rad
J2 = D * 3e-5; % Nms^s/rad
M3 = E * 5e-2; % Kg
B1 = F * 3e-6; % Nms/rad
B2 = G * 3e-4; % Nms/rad
B3 = H * 3e-1; % Ns/m
K3 = A; % N/m

% Table 2
K2 = A * 1e3; % V/rad
sg = B * 1e2; % rad/s
sh = C * 1e2; % rad/s
wh = D * 1e2; % rad/s

% Table 3
Rw = A/5; % ohm
Lw = B * 1e-3; % mH
Km = C * 1e-3; % Nm/A
Jm = E * 2e-6; % Nms^2/rad
Bm = D * 2e-5; % Nms/rad

% Table 4
CF = B * 200; % Hz
DC = C * 2; 

% Table 5
Res = 0.1; % rad/s
TargPM = 40; % degree
OSu = 50; 
Ts = 80; 
Tr = Ts; 
Ess = 0; 

G2 = s + sg; 
H2 = (s + sh + j*wh)*(s + sh - j*wh);

%% Question 1
Peak = 2.59991;
Steady_State = 2.08997;
Overshoot = (Peak - Steady_State) / Steady_State;

syms Zeta;
equation1 = Overshoot == exp(-Zeta * pi / (1 - Zeta^2)^0.5);
Zeta = solve(equation1, Zeta, 'Real', true);
Zeta = double(Zeta);

Ts = 0.00307046;
Wn = 4 / (Zeta*Ts);

Q1.Ga = Steady_State * Wn^2 / (s^2 + 2 * Zeta * Wn * s + Wn^2);

%% Question 2
Hs = K2 * (1 + G2) / (1 + G2 + H2); 
Q2.Ks = dcgain(Hs);
Q2.Ds = Hs / dcgain(Hs);

%% Question 3
n12 = Z2 / Z1;            % speed ratio w1/w2 (magnitude)
PD2 = Z2 * Mod;           % pitch diameter (m)
r2  = PD2 / 2;            % pitch radius (m)

J_rack_2 = M3 * r2^2;
B_rack_2 = B3 * r2^2;
K_rack_2 = K3 * r2^2;

J_shaft2 = J2 + Jm + J_rack_2;
B_shaft2 = B2 + Bm + B_rack_2;
K_shaft2 = K_rack_2;

Q3.Jj = J1 + J_shaft2 / (n12^2);
Q3.Bj = B1 + B_shaft2 / (n12^2);
Q3.Kj = K_shaft2 / (n12^2);

%% Question 4
n = 1 / n12;

Q4.Ye = 1 / (Lw*s + Rw);

Q4.Ym = s / (Q3.Jj*s^2 + Q3.Bj*s + Q3.Kj);

forward = Q4.Ye * (n*Km) * Q4.Ym;
w_over_v = feedback(forward, (n*Km));

Q4.Gp = minreal(w_over_v / s);   % x4/x3 (rad/V)

%% Question 5 (State Space for plant Gp)
%% Question 5  (State Space of Gp)
% x = [iw; wj; tauKj], u = x3 = vw, y = [fKw; fBw]

Kjt = (Z1*Mod)/2;     % m/rad  ( = r2/n12 )

Kmj = n*Km;           % motor constant mapped into joint coordinates

Q5.A = [ -Rw/Lw,        -Kmj/Lw,           0;
          Kmj/Q3.Jj,    -Q3.Bj/Q3.Jj,     -1/Q3.Jj;
          0,             Q3.Kj,            0 ];

Q5.B = [ 1/Lw;
         0;
         0 ];
Kjt = (Z2*Mod)/2;  

% y1 = fKw = -(tauKj / Kjt)   (spring force opposes displacement)
% y2 = fBw = -(B3 * d_dot) = -(B3*(Kjt*wj))  (friction opposes velocity)
Q5.C = [ 0, 0, 1/Kjt;
         0, B3*Kjt, 0 ];
n12 = Z2/Z1;
Kjt = (Z2*Mod)/2;

Q5.C = [ 0, 0, 1/(n12*Kjt);
         0, B3*Kjt, 0 ];

Q5.D = [0;0];

%% Question 6 (IIR Filter)
% GHs = x5/x2 (see Fig 4)
Q6.GHs = minreal(Q2.Ks * Q2.Ds * Q4.Gp * Q1.Ga);

% dominant pole (smallest magnitude real part that's negative)
p = pole(Q6.GHs);
real_parts = real(p);
% Get negative real parts only
negative_real = real_parts(real_parts < 0);
% Find the one closest to zero (least stable/most dominant)
Q6.wd = abs(max(negative_real));

% ROUND-UP to next 0.1 rad/s
Q6.wd = ceil(Q6.wd/Res)*Res;

% sampling period
Tsamp = 1/CF;

% Calculate Nf with the -0.5 adjustment like in f1prac.m
Q6.Nf = CF/(10*Q6.wd) - 0.5;

% corresponding tau and beta
Q6.tau  = Q6.Nf * Tsamp;                 % seconds
Q6.tau  = round(Q6.tau, 2, "significant");
Q6.beta = exp(-Tsamp/Q6.tau);
%% Question 7 (FIR filter coefficient count)
Tcycle = 1/CF;
Q7.num = ceil(4*Q6.tau/Tcycle);

%% Question 8
Q8.N = Q6.Nf+0.5;
Q8.Hc = 1/(Q8.N/CF*s + 1) / dcgain(Hs);

%% Question 9 (System Model)
Q9.G  = Q1.Ga * Q4.Gp;
Q9.H  = Q8.Hc * Q2.Ks * Q2.Ds;  % Hc * Hs (where Hs = Ks * Ds)
Q9.GH = Q9.G * Q9.H;

% Static gains for coordinate transformation
r2 = (Z2*Mod)/2;     % radius of gear 2 (m)
n12 = Z2/Z1;         % gear ratio

% Joint (Gear 1) to Task (rack) conversion
Q9.Kjt = r2/n12;     % m/rad  (equivalent radius at Gear 1)
Q9.Ktj = n12/r2;     % rad/m  (inverse)

%% Question 10 (Partial Dynamics)
% Derivative filter pole (same as feedback filter)
p = -CF/Q8.N;
Q10.Dp = 1/(s);

% Find initial gain for marginal stability
[Q10.K0, ~, ~, ~] = margin(Q9.GH * Q10.Dp);

% Find crossover frequency at marginal stability
[~, ~, Q10.wxo, ~] = margin(Q9.GH * Q10.Dp * Q10.K0);


%% Question 11 - Complete solution

% We found Z = -1.7 (negative real zero location)
PM_best = -inf;
Z_best = -Res;

for Z_test = -Res:-Res:(-20*Q10.wxo)
    D_test = (s - Z_test) / (-Z_test * s);
    [~, PM] = margin(Q10.K0 * D_test * Q9.G * Q9.H);
    if PM > PM_best
        PM_best = PM;
        Z_best = Z_test;
    end
end

Q11.Z = Z_best;  % -1.7
Q11.PM = PM_best;  % Phase margin in degrees
Q11.D = (s - Q11.Z) / (-Q11.Z * s);  % Full dynamics

% Verify:
fprintf('Q11.Z = %.2f rad/s\n', Q11.Z);
fprintf('Q11.PM = %.2f degrees\n', Q11.PM);
fprintf('Q11.D = ');
Q11.D

%% Question 12 (Master Gain)
oltf = Q9.GH * Q11.D;

% Search for K that gives TargPM (now correctly = 40 degrees)
K_search = linspace(0.01*Q10.K0, 2*Q10.K0, 5000);
PM_search = zeros(size(K_search));

for i = 1:length(K_search)
    [~, PM_search(i)] = margin(K_search(i) * oltf);
end

[~, idx] = min(abs(PM_search - TargPM));
Q12.K = K_search(idx);

%% Question 13
p = -CF/Q8.N;
Z = Q11.Z;

Q13.Kp = real(-1/p - 1/Q11.Z) * 1.15;
Q13.Ki = 1.25;

%% Question 14 (Reference Performance Metrics)
% Closed loop from x2 (desired joint angle) to x4 (actual joint angle)
% For K=1 (reference)
K_ref = 1;
cltf = feedback(K_ref * Q11.D * Q9.G, Q9.H);

info = stepinfo(cltf, 'RiseTimeLimits', [0, 1]);

Q14.Tr = info.RiseTime;
Q14.Tp = info.PeakTime;
Q14.Ts = info.SettlingTime;
Q14.OSy = info.Overshoot;

% For input overshoot OSu: this is the overshoot of x3 (control voltage)
% x3/x2 = D/(1 + D*G*H)
cltf_control = feedback(K_ref * Q11.D, Q9.G * Q9.H);
info_control = stepinfo(cltf_control, 'RiseTimeLimits', [0, 1]);
Q14.OSu = info_control.Overshoot;

Q14.Ess = abs(1 - dcgain(cltf)) * 100;
%% Functions

function k = findKforPM(G, initial_k, targetPhaseMargin)
    % Function to find the gain (k) that achieves a target phase margin
    % for a given open-loop transfer function (G).
    %
    % Inputs:
    %   G - Open-loop transfer function (as a tf object)
    %   initial_k - Initial gain value
    %   targetPhaseMargin - Desired phase margin (in degrees)
    %
    % Output:
    %   k - Gain that achieves the target phase margin

    % Ensure input transfer function has gain applied
    Gk = @(k) k * G;

    % Objective function: Find the difference between current and target phase margin
    function pm_error = phaseMarginError(k)
        [~, pm] = margin(Gk(k));
        pm_error = abs(pm - targetPhaseMargin);
    end

    % Use fminsearch to minimize the phase margin error
    options = optimset('TolX', 1e-6, 'Display', 'iter');
    k = fminsearch(@phaseMarginError, initial_k, options);

    % Display the resulting gain and phase margin
    [gm, pm, wgc] = margin(Gk(k));
    fprintf('Gain: %.4f\n', k);
    fprintf('Phase Margin: %.2f degrees\n', pm);
    fprintf('Gain Margin: %.2f dB\n', 20*log10(gm));
    fprintf('Gain Crossover Frequency: %.2f rad/s\n', wgc);
end

 x2Submit